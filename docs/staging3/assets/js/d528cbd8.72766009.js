"use strict";(self.webpackChunkclickhouse=self.webpackChunkclickhouse||[]).push([[64179],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return m}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),o=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=o(e.components);return a.createElement(p.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,p=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=o(n),m=r,g=d["".concat(p,".").concat(m)]||d[m]||c[m]||l;return n?a.createElement(g,i(i({ref:t},u),{},{components:n})):a.createElement(g,i({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,i=new Array(l);i[0]=d;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var o=2;o<l;o++)i[o]=n[o];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},18253:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return p},default:function(){return m},frontMatter:function(){return s},metadata:function(){return o},toc:function(){return c}});var a=n(87462),r=n(63366),l=(n(67294),n(3905)),i=["components"],s={sidebar_position:40,sidebar_label:"Strings"},p="Functions for Working with Strings",o={unversionedId:"en/sql-reference/functions/string-functions",id:"en/sql-reference/functions/string-functions",title:"Functions for Working with Strings",description:"functions-for-working-with-strings}",source:"@site/docs/en/sql-reference/functions/string-functions.md",sourceDirName:"en/sql-reference/functions",slug:"/en/sql-reference/functions/string-functions",permalink:"/docs/staging4/docs/en/sql-reference/functions/string-functions",tags:[],version:"current",sidebarPosition:40,frontMatter:{sidebar_position:40,sidebar_label:"Strings"},sidebar:"tutorialSidebar",previous:{title:"Dates and Times",permalink:"/docs/staging4/docs/en/sql-reference/functions/date-time-functions"},next:{title:"For Searching in Strings",permalink:"/docs/staging4/docs/en/sql-reference/functions/string-search-functions"}},u={},c=[{value:"empty",id:"empty",level:2},{value:"notEmpty",id:"notempty",level:2},{value:"length",id:"length",level:2},{value:"lengthUTF8",id:"lengthutf8",level:2},{value:"char_length, CHAR_LENGTH",id:"char-length",level:2},{value:"character_length, CHARACTER_LENGTH",id:"character-length",level:2},{value:"leftPad",id:"leftpad",level:2},{value:"leftPadUTF8",id:"leftpadutf8",level:2},{value:"rightPad",id:"rightpad",level:2},{value:"rightPadUTF8",id:"rightpadutf8",level:2},{value:"lower, lcase",id:"lower",level:2},{value:"upper, ucase",id:"upper",level:2},{value:"lowerUTF8",id:"lowerutf8",level:2},{value:"upperUTF8",id:"upperutf8",level:2},{value:"isValidUTF8",id:"isvalidutf8",level:2},{value:"toValidUTF8",id:"tovalidutf8",level:2},{value:"repeat",id:"repeat",level:2},{value:"reverse",id:"reverse",level:2},{value:"reverseUTF8",id:"reverseutf8",level:2},{value:"format(pattern, s0, s1, \u2026)",id:"format",level:2},{value:"concat",id:"concat",level:2},{value:"concatAssumeInjective",id:"concatassumeinjective",level:2},{value:"substring(s, offset, length), mid(s, offset, length), substr(s, offset, length)",id:"substring",level:2},{value:"substringUTF8(s, offset, length)",id:"substringutf8",level:2},{value:"appendTrailingCharIfAbsent(s, c)",id:"appendtrailingcharifabsent",level:2},{value:"convertCharset(s, from, to)",id:"convertcharset",level:2},{value:"base64Encode(s)",id:"base64encode",level:2},{value:"base64Decode(s)",id:"base64decode",level:2},{value:"tryBase64Decode(s)",id:"trybase64decode",level:2},{value:"endsWith(s, suffix)",id:"endswith",level:2},{value:"startsWith(str, prefix)",id:"startswith",level:2},{value:"trim",id:"trim",level:2},{value:"trimLeft",id:"trimleft",level:2},{value:"trimRight",id:"trimright",level:2},{value:"trimBoth",id:"trimboth",level:2},{value:"CRC32(s)",id:"crc32",level:2},{value:"CRC32IEEE(s)",id:"crc32ieee",level:2},{value:"CRC64(s)",id:"crc64",level:2},{value:"normalizeQuery",id:"normalized-query",level:2},{value:"normalizedQueryHash",id:"normalized-query-hash",level:2},{value:"normalizeUTF8NFC",id:"normalizeutf8nfc",level:2},{value:"normalizeUTF8NFD",id:"normalizeutf8nfd",level:2},{value:"normalizeUTF8NFKC",id:"normalizeutf8nfkc",level:2},{value:"normalizeUTF8NFKD",id:"normalizeutf8nfkd",level:2},{value:"encodeXMLComponent",id:"encode-xml-component",level:2},{value:"decodeXMLComponent",id:"decode-xml-component",level:2},{value:"extractTextFromHTML",id:"extracttextfromhtml",level:2}],d={toc:c};function m(e){var t=e.components,n=(0,r.Z)(e,i);return(0,l.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"functions-for-working-with-strings"},"Functions for Working with Strings"),(0,l.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,l.kt)("div",{parentName:"div",className:"admonition-heading"},(0,l.kt)("h5",{parentName:"div"},(0,l.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,l.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,l.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,l.kt)("div",{parentName:"div",className:"admonition-content"},(0,l.kt)("p",{parentName:"div"},"Functions for ",(0,l.kt)("a",{parentName:"p",href:"/docs/staging4/docs/en/sql-reference/functions/string-search-functions"},"searching")," and ",(0,l.kt)("a",{parentName:"p",href:"/docs/staging4/docs/en/sql-reference/functions/string-replace-functions"},"replacing")," in strings are described separately."))),(0,l.kt)("h2",{id:"empty"},"empty"),(0,l.kt)("p",null,"Checks whether the input string is empty."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Syntax")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"empty(x)\n")),(0,l.kt)("p",null,"A string is considered non-empty if it contains at least one byte, even if this is a space or a null byte."),(0,l.kt)("p",null,"The function also works for ",(0,l.kt)("a",{parentName:"p",href:"/docs/staging4/docs/en/sql-reference/functions/array-functions#function-empty"},"arrays")," or ",(0,l.kt)("a",{parentName:"p",href:"/docs/staging4/docs/en/sql-reference/functions/uuid-functions#empty"},"UUID"),"."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"x")," \u2014 Input value. ",(0,l.kt)("a",{parentName:"li",href:"/docs/staging4/docs/en/sql-reference/data-types/string"},"String"),".")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returned value")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Returns ",(0,l.kt)("inlineCode",{parentName:"li"},"1")," for an empty string or ",(0,l.kt)("inlineCode",{parentName:"li"},"0")," for a non-empty string.")),(0,l.kt)("p",null,"Type: ",(0,l.kt)("a",{parentName:"p",href:"/docs/staging4/docs/en/sql-reference/data-types/int-uint"},"UInt8"),"."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("p",null,"Query:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT empty('');\n")),(0,l.kt)("p",null,"Result:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-text"},"\u250c\u2500empty('')\u2500\u2510\n\u2502         1 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")),(0,l.kt)("h2",{id:"notempty"},"notEmpty"),(0,l.kt)("p",null,"Checks whether the input string is non-empty."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Syntax")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"notEmpty(x)\n")),(0,l.kt)("p",null,"A string is considered non-empty if it contains at least one byte, even if this is a space or a null byte."),(0,l.kt)("p",null,"The function also works for ",(0,l.kt)("a",{parentName:"p",href:"/docs/staging4/docs/en/sql-reference/functions/array-functions#function-notempty"},"arrays")," or ",(0,l.kt)("a",{parentName:"p",href:"/docs/staging4/docs/en/sql-reference/functions/uuid-functions#notempty"},"UUID"),"."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"x")," \u2014 Input value. ",(0,l.kt)("a",{parentName:"li",href:"/docs/staging4/docs/en/sql-reference/data-types/string"},"String"),".")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returned value")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Returns ",(0,l.kt)("inlineCode",{parentName:"li"},"1")," for a non-empty string or ",(0,l.kt)("inlineCode",{parentName:"li"},"0")," for an empty string string.")),(0,l.kt)("p",null,"Type: ",(0,l.kt)("a",{parentName:"p",href:"/docs/staging4/docs/en/sql-reference/data-types/int-uint"},"UInt8"),"."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("p",null,"Query:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT notEmpty('text');\n")),(0,l.kt)("p",null,"Result:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-text"},"\u250c\u2500notEmpty('text')\u2500\u2510\n\u2502                1 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")),(0,l.kt)("h2",{id:"length"},"length"),(0,l.kt)("p",null,"Returns the length of a string in bytes (not in characters, and not in code points).\nThe result type is UInt64.\nThe function also works for arrays."),(0,l.kt)("h2",{id:"lengthutf8"},"lengthUTF8"),(0,l.kt)("p",null,"Returns the length of a string in Unicode code points (not in characters), assuming that the string contains a set of bytes that make up UTF-8 encoded text. If this assumption is not met, it returns some result (it does not throw an exception).\nThe result type is UInt64."),(0,l.kt)("h2",{id:"char-length"},"char_length, CHAR_LENGTH"),(0,l.kt)("p",null,"Returns the length of a string in Unicode code points (not in characters), assuming that the string contains a set of bytes that make up UTF-8 encoded text. If this assumption is not met, it returns some result (it does not throw an exception).\nThe result type is UInt64."),(0,l.kt)("h2",{id:"character-length"},"character_length, CHARACTER_LENGTH"),(0,l.kt)("p",null,"Returns the length of a string in Unicode code points (not in characters), assuming that the string contains a set of bytes that make up UTF-8 encoded text. If this assumption is not met, it returns some result (it does not throw an exception).\nThe result type is UInt64."),(0,l.kt)("h2",{id:"leftpad"},"leftPad"),(0,l.kt)("p",null,"Pads the current string from the left with spaces or a specified string (multiple times, if needed) until the resulting string reaches the given length. Similarly to the MySQL ",(0,l.kt)("inlineCode",{parentName:"p"},"LPAD")," function."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Syntax")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"leftPad('string', 'length'[, 'pad_string'])\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"string")," \u2014 Input string that needs to be padded. ",(0,l.kt)("a",{parentName:"li",href:"/docs/staging4/docs/en/sql-reference/data-types/string"},"String"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"length")," \u2014 The length of the resulting string. ",(0,l.kt)("a",{parentName:"li",href:"/docs/staging4/docs/en/sql-reference/data-types/int-uint"},"UInt"),". If the value is less than the input string length, then the input string is returned as-is."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"pad_string")," \u2014 The string to pad the input string with. ",(0,l.kt)("a",{parentName:"li",href:"/docs/staging4/docs/en/sql-reference/data-types/string"},"String"),". Optional. If not specified, then the input string is padded with spaces.")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returned value")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The resulting string of the given length.")),(0,l.kt)("p",null,"Type: ",(0,l.kt)("a",{parentName:"p",href:"/docs/staging4/docs/en/sql-reference/data-types/string"},"String"),"."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("p",null,"Query:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT leftPad('abc', 7, '*'), leftPad('def', 7);\n")),(0,l.kt)("p",null,"Result:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-text"},"\u250c\u2500leftPad('abc', 7, '*')\u2500\u252c\u2500leftPad('def', 7)\u2500\u2510\n\u2502 ****abc                \u2502     def           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")),(0,l.kt)("h2",{id:"leftpadutf8"},"leftPadUTF8"),(0,l.kt)("p",null,"Pads the current string from the left with spaces or a specified string (multiple times, if needed) until the resulting string reaches the given length. Similarly to the MySQL ",(0,l.kt)("inlineCode",{parentName:"p"},"LPAD")," function. While in the ",(0,l.kt)("a",{parentName:"p",href:"#leftpad"},"leftPad")," function the length is measured in bytes, here in the ",(0,l.kt)("inlineCode",{parentName:"p"},"leftPadUTF8")," function it is measured in code points."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Syntax")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"leftPadUTF8('string','length'[, 'pad_string'])\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"string")," \u2014 Input string that needs to be padded. ",(0,l.kt)("a",{parentName:"li",href:"/docs/staging4/docs/en/sql-reference/data-types/string"},"String"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"length")," \u2014 The length of the resulting string. ",(0,l.kt)("a",{parentName:"li",href:"/docs/staging4/docs/en/sql-reference/data-types/int-uint"},"UInt"),". If the value is less than the input string length, then the input string is returned as-is."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"pad_string")," \u2014 The string to pad the input string with. ",(0,l.kt)("a",{parentName:"li",href:"/docs/staging4/docs/en/sql-reference/data-types/string"},"String"),". Optional. If not specified, then the input string is padded with spaces.")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returned value")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The resulting string of the given length.")),(0,l.kt)("p",null,"Type: ",(0,l.kt)("a",{parentName:"p",href:"/docs/staging4/docs/en/sql-reference/data-types/string"},"String"),"."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("p",null,"Query:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT leftPadUTF8('\u0430\u0431\u0432\u0433', 7, '*'), leftPadUTF8('\u0434\u0435\u0436\u0437', 7);\n")),(0,l.kt)("p",null,"Result:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-text"},"\u250c\u2500leftPadUTF8('\u0430\u0431\u0432\u0433', 7, '*')\u2500\u252c\u2500leftPadUTF8('\u0434\u0435\u0436\u0437', 7)\u2500\u2510\n\u2502 ***\u0430\u0431\u0432\u0433                     \u2502    \u0434\u0435\u0436\u0437                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")),(0,l.kt)("h2",{id:"rightpad"},"rightPad"),(0,l.kt)("p",null,"Pads the current string from the right with spaces or a specified string (multiple times, if needed) until the resulting string reaches the given length. Similarly to the MySQL ",(0,l.kt)("inlineCode",{parentName:"p"},"RPAD")," function."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Syntax")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"rightPad('string', 'length'[, 'pad_string'])\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"string")," \u2014 Input string that needs to be padded. ",(0,l.kt)("a",{parentName:"li",href:"/docs/staging4/docs/en/sql-reference/data-types/string"},"String"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"length")," \u2014 The length of the resulting string. ",(0,l.kt)("a",{parentName:"li",href:"/docs/staging4/docs/en/sql-reference/data-types/int-uint"},"UInt"),". If the value is less than the input string length, then the input string is returned as-is."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"pad_string")," \u2014 The string to pad the input string with. ",(0,l.kt)("a",{parentName:"li",href:"/docs/staging4/docs/en/sql-reference/data-types/string"},"String"),". Optional. If not specified, then the input string is padded with spaces.")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returned value")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The resulting string of the given length.")),(0,l.kt)("p",null,"Type: ",(0,l.kt)("a",{parentName:"p",href:"/docs/staging4/docs/en/sql-reference/data-types/string"},"String"),"."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("p",null,"Query:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT rightPad('abc', 7, '*'), rightPad('abc', 7);\n")),(0,l.kt)("p",null,"Result:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-text"},"\u250c\u2500rightPad('abc', 7, '*')\u2500\u252c\u2500rightPad('abc', 7)\u2500\u2510\n\u2502 abc****                 \u2502 abc                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")),(0,l.kt)("h2",{id:"rightpadutf8"},"rightPadUTF8"),(0,l.kt)("p",null,"Pads the current string from the right with spaces or a specified string (multiple times, if needed) until the resulting string reaches the given length. Similarly to the MySQL ",(0,l.kt)("inlineCode",{parentName:"p"},"RPAD")," function. While in the ",(0,l.kt)("a",{parentName:"p",href:"#rightpad"},"rightPad")," function the length is measured in bytes, here in the ",(0,l.kt)("inlineCode",{parentName:"p"},"rightPadUTF8")," function it is measured in code points."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Syntax")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"rightPadUTF8('string','length'[, 'pad_string'])\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"string")," \u2014 Input string that needs to be padded. ",(0,l.kt)("a",{parentName:"li",href:"/docs/staging4/docs/en/sql-reference/data-types/string"},"String"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"length")," \u2014 The length of the resulting string. ",(0,l.kt)("a",{parentName:"li",href:"/docs/staging4/docs/en/sql-reference/data-types/int-uint"},"UInt"),". If the value is less than the input string length, then the input string is returned as-is."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"pad_string")," \u2014 The string to pad the input string with. ",(0,l.kt)("a",{parentName:"li",href:"/docs/staging4/docs/en/sql-reference/data-types/string"},"String"),". Optional. If not specified, then the input string is padded with spaces.")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returned value")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The resulting string of the given length.")),(0,l.kt)("p",null,"Type: ",(0,l.kt)("a",{parentName:"p",href:"/docs/staging4/docs/en/sql-reference/data-types/string"},"String"),"."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("p",null,"Query:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT rightPadUTF8('\u0430\u0431\u0432\u0433', 7, '*'), rightPadUTF8('\u0430\u0431\u0432\u0433', 7);\n")),(0,l.kt)("p",null,"Result:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-text"},"\u250c\u2500rightPadUTF8('\u0430\u0431\u0432\u0433', 7, '*')\u2500\u252c\u2500rightPadUTF8('\u0430\u0431\u0432\u0433', 7)\u2500\u2510\n\u2502 \u0430\u0431\u0432\u0433***                      \u2502 \u0430\u0431\u0432\u0433                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")),(0,l.kt)("h2",{id:"lower"},"lower, lcase"),(0,l.kt)("p",null,"Converts ASCII Latin symbols in a string to lowercase."),(0,l.kt)("h2",{id:"upper"},"upper, ucase"),(0,l.kt)("p",null,"Converts ASCII Latin symbols in a string to uppercase."),(0,l.kt)("h2",{id:"lowerutf8"},"lowerUTF8"),(0,l.kt)("p",null,"Converts a string to lowercase, assuming the string contains a set of bytes that make up a UTF-8 encoded text.\nIt does not detect the language. So for Turkish the result might not be exactly correct.\nIf the length of the UTF-8 byte sequence is different for upper and lower case of a code point, the result may be incorrect for this code point.\nIf the string contains a set of bytes that is not UTF-8, then the behavior is undefined."),(0,l.kt)("h2",{id:"upperutf8"},"upperUTF8"),(0,l.kt)("p",null,"Converts a string to uppercase, assuming the string contains a set of bytes that make up a UTF-8 encoded text.\nIt does not detect the language. So for Turkish the result might not be exactly correct.\nIf the length of the UTF-8 byte sequence is different for upper and lower case of a code point, the result may be incorrect for this code point.\nIf the string contains a set of bytes that is not UTF-8, then the behavior is undefined."),(0,l.kt)("h2",{id:"isvalidutf8"},"isValidUTF8"),(0,l.kt)("p",null,"Returns 1, if the set of bytes is valid UTF-8 encoded, otherwise 0."),(0,l.kt)("h2",{id:"tovalidutf8"},"toValidUTF8"),(0,l.kt)("p",null,"Replaces invalid UTF-8 characters by the ",(0,l.kt)("inlineCode",{parentName:"p"},"\ufffd")," (U+FFFD) character. All running in a row invalid characters are collapsed into the one replacement character."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"toValidUTF8(input_string)\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"input_string")," \u2014 Any set of bytes represented as the ",(0,l.kt)("a",{parentName:"li",href:"/docs/staging4/docs/en/sql-reference/data-types/string"},"String")," data type object.")),(0,l.kt)("p",null,"Returned value: Valid UTF-8 string."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT toValidUTF8('\\x61\\xF0\\x80\\x80\\x80b');\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-text"},"\u250c\u2500toValidUTF8('a\ufffd\ufffd\ufffd\ufffdb')\u2500\u2510\n\u2502 a\ufffdb                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")),(0,l.kt)("h2",{id:"repeat"},"repeat"),(0,l.kt)("p",null,"Repeats a string as many times as specified and concatenates the replicated values as a single string."),(0,l.kt)("p",null,"Alias: ",(0,l.kt)("inlineCode",{parentName:"p"},"REPEAT"),"."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Syntax")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"repeat(s, n)\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"s")," \u2014 The string to repeat. ",(0,l.kt)("a",{parentName:"li",href:"/docs/staging4/docs/en/sql-reference/data-types/string"},"String"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"n")," \u2014 The number of times to repeat the string. ",(0,l.kt)("a",{parentName:"li",href:"/docs/staging4/docs/en/sql-reference/data-types/int-uint"},"UInt"),".")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returned value")),(0,l.kt)("p",null,"The single string, which contains the string ",(0,l.kt)("inlineCode",{parentName:"p"},"s")," repeated ",(0,l.kt)("inlineCode",{parentName:"p"},"n")," times. If ",(0,l.kt)("inlineCode",{parentName:"p"},"n")," \\< 1, the function returns empty string."),(0,l.kt)("p",null,"Type: ",(0,l.kt)("inlineCode",{parentName:"p"},"String"),"."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("p",null,"Query:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT repeat('abc', 10);\n")),(0,l.kt)("p",null,"Result:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-text"},"\u250c\u2500repeat('abc', 10)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 abcabcabcabcabcabcabcabcabcabc \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")),(0,l.kt)("h2",{id:"reverse"},"reverse"),(0,l.kt)("p",null,"Reverses the string (as a sequence of bytes)."),(0,l.kt)("h2",{id:"reverseutf8"},"reverseUTF8"),(0,l.kt)("p",null,"Reverses a sequence of Unicode code points, assuming that the string contains a set of bytes representing a UTF-8 text. Otherwise, it does something else (it does not throw an exception)."),(0,l.kt)("h2",{id:"format"},"format(pattern, s0, s1, \u2026)"),(0,l.kt)("p",null,"Formatting constant pattern with the string listed in the arguments. ",(0,l.kt)("inlineCode",{parentName:"p"},"pattern")," is a simplified Python format pattern. Format string contains \u201creplacement fields\u201d surrounded by curly braces ",(0,l.kt)("inlineCode",{parentName:"p"},"{}"),". Anything that is not contained in braces is considered literal text, which is copied unchanged to the output. If you need to include a brace character in the literal text, it can be escaped by doubling: ",(0,l.kt)("inlineCode",{parentName:"p"},"{{ '{{' }}")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"{{ '}}' }}"),". Field names can be numbers (starting from zero) or empty (then they are treated as consequence numbers)."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT format('{1} {0} {1}', 'World', 'Hello')\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-text"},"\u250c\u2500format('{1} {0} {1}', 'World', 'Hello')\u2500\u2510\n\u2502 Hello World Hello                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT format('{} {}', 'Hello', 'World')\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-text"},"\u250c\u2500format('{} {}', 'Hello', 'World')\u2500\u2510\n\u2502 Hello World                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")),(0,l.kt)("h2",{id:"concat"},"concat"),(0,l.kt)("p",null,"Concatenates the strings listed in the arguments, without a separator."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Syntax")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"concat(s1, s2, ...)\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments")),(0,l.kt)("p",null,"Values of type String or FixedString."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returned values")),(0,l.kt)("p",null,"Returns the String that results from concatenating the arguments."),(0,l.kt)("p",null,"If any of argument values is ",(0,l.kt)("inlineCode",{parentName:"p"},"NULL"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"concat")," returns ",(0,l.kt)("inlineCode",{parentName:"p"},"NULL"),"."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("p",null,"Query:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT concat('Hello, ', 'World!');\n")),(0,l.kt)("p",null,"Result:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-text"},"\u250c\u2500concat('Hello, ', 'World!')\u2500\u2510\n\u2502 Hello, World!               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")),(0,l.kt)("h2",{id:"concatassumeinjective"},"concatAssumeInjective"),(0,l.kt)("p",null,"Same as ",(0,l.kt)("a",{parentName:"p",href:"#concat"},"concat"),", the difference is that you need to ensure that ",(0,l.kt)("inlineCode",{parentName:"p"},"concat(s1, s2, ...) \u2192 sn")," is injective, it will be used for optimization of GROUP BY."),(0,l.kt)("p",null,"The function is named \u201cinjective\u201d if it always returns different result for different values of arguments. In other words: different arguments never yield identical result."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Syntax")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"concatAssumeInjective(s1, s2, ...)\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments")),(0,l.kt)("p",null,"Values of type String or FixedString."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returned values")),(0,l.kt)("p",null,"Returns the String that results from concatenating the arguments."),(0,l.kt)("p",null,"If any of argument values is ",(0,l.kt)("inlineCode",{parentName:"p"},"NULL"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"concatAssumeInjective")," returns ",(0,l.kt)("inlineCode",{parentName:"p"},"NULL"),"."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("p",null,"Input table:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE key_val(`key1` String, `key2` String, `value` UInt32) ENGINE = TinyLog;\nINSERT INTO key_val VALUES ('Hello, ','World',1), ('Hello, ','World',2), ('Hello, ','World!',3), ('Hello',', World!',2);\nSELECT * from key_val;\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-text"},"\u250c\u2500key1\u2500\u2500\u2500\u2500\u252c\u2500key2\u2500\u2500\u2500\u2500\u2500\u252c\u2500value\u2500\u2510\n\u2502 Hello,  \u2502 World    \u2502     1 \u2502\n\u2502 Hello,  \u2502 World    \u2502     2 \u2502\n\u2502 Hello,  \u2502 World!   \u2502     3 \u2502\n\u2502 Hello   \u2502 , World! \u2502     2 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")),(0,l.kt)("p",null,"Query:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT concat(key1, key2), sum(value) FROM key_val GROUP BY concatAssumeInjective(key1, key2);\n")),(0,l.kt)("p",null,"Result:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-text"},"\u250c\u2500concat(key1, key2)\u2500\u252c\u2500sum(value)\u2500\u2510\n\u2502 Hello, World!      \u2502          3 \u2502\n\u2502 Hello, World!      \u2502          2 \u2502\n\u2502 Hello, World       \u2502          3 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")),(0,l.kt)("h2",{id:"substring"},"substring(s, offset, length), mid(s, offset, length), substr(s, offset, length)"),(0,l.kt)("p",null,"Returns a substring starting with the byte from the \u2018offset\u2019 index that is \u2018length\u2019 bytes long. Character indexing starts from one (as in standard SQL). The \u2018offset\u2019 and \u2018length\u2019 arguments must be constants."),(0,l.kt)("h2",{id:"substringutf8"},"substringUTF8(s, offset, length)"),(0,l.kt)("p",null,"The same as \u2018substring\u2019, but for Unicode code points. Works under the assumption that the string contains a set of bytes representing a UTF-8 encoded text. If this assumption is not met, it returns some result (it does not throw an exception)."),(0,l.kt)("h2",{id:"appendtrailingcharifabsent"},"appendTrailingCharIfAbsent(s, c)"),(0,l.kt)("p",null,"If the \u2018s\u2019 string is non-empty and does not contain the \u2018c\u2019 character at the end, it appends the \u2018c\u2019 character to the end."),(0,l.kt)("h2",{id:"convertcharset"},"convertCharset(s, from, to)"),(0,l.kt)("p",null,"Returns the string \u2018s\u2019 that was converted from the encoding in \u2018from\u2019 to the encoding in \u2018to\u2019."),(0,l.kt)("h2",{id:"base64encode"},"base64Encode(s)"),(0,l.kt)("p",null,"Encodes \u2018s\u2019 string into base64"),(0,l.kt)("p",null,"Alias: ",(0,l.kt)("inlineCode",{parentName:"p"},"TO_BASE64"),"."),(0,l.kt)("h2",{id:"base64decode"},"base64Decode(s)"),(0,l.kt)("p",null,"Decode base64-encoded string \u2018s\u2019 into original string. In case of failure raises an exception."),(0,l.kt)("p",null,"Alias: ",(0,l.kt)("inlineCode",{parentName:"p"},"FROM_BASE64"),"."),(0,l.kt)("h2",{id:"trybase64decode"},"tryBase64Decode(s)"),(0,l.kt)("p",null,"Similar to base64Decode, but in case of error an empty string would be returned."),(0,l.kt)("h2",{id:"endswith"},"endsWith(s, suffix)"),(0,l.kt)("p",null,"Returns whether to end with the specified suffix. Returns 1 if the string ends with the specified suffix, otherwise it returns 0."),(0,l.kt)("h2",{id:"startswith"},"startsWith(str, prefix)"),(0,l.kt)("p",null,"Returns 1 whether string starts with the specified prefix, otherwise it returns 0."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT startsWith('Spider-Man', 'Spi');\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returned values")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"1, if the string starts with the specified prefix."),(0,l.kt)("li",{parentName:"ul"},"0, if the string does not start with the specified prefix.")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("p",null,"Query:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT startsWith('Hello, world!', 'He');\n")),(0,l.kt)("p",null,"Result:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-text"},"\u250c\u2500startsWith('Hello, world!', 'He')\u2500\u2510\n\u2502                                 1 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")),(0,l.kt)("h2",{id:"trim"},"trim"),(0,l.kt)("p",null,"Removes all specified characters from the start or end of a string.\nBy default removes all consecutive occurrences of common whitespace (ASCII character 32) from both ends of a string."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Syntax")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"trim([[LEADING|TRAILING|BOTH] trim_character FROM] input_string)\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"trim_character")," \u2014 Specified characters for trim. ",(0,l.kt)("a",{parentName:"li",href:"/docs/staging4/docs/en/sql-reference/data-types/string"},"String"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"input_string")," \u2014 String for trim. ",(0,l.kt)("a",{parentName:"li",href:"/docs/staging4/docs/en/sql-reference/data-types/string"},"String"),".")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returned value")),(0,l.kt)("p",null,"A string without leading and (or) trailing specified characters."),(0,l.kt)("p",null,"Type: ",(0,l.kt)("inlineCode",{parentName:"p"},"String"),"."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("p",null,"Query:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT trim(BOTH ' ()' FROM '(   Hello, world!   )');\n")),(0,l.kt)("p",null,"Result:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-text"},"\u250c\u2500trim(BOTH ' ()' FROM '(   Hello, world!   )')\u2500\u2510\n\u2502 Hello, world!                                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")),(0,l.kt)("h2",{id:"trimleft"},"trimLeft"),(0,l.kt)("p",null,"Removes all consecutive occurrences of common whitespace (ASCII character 32) from the beginning of a string. It does not remove other kinds of whitespace characters (tab, no-break space, etc.)."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Syntax")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"trimLeft(input_string)\n")),(0,l.kt)("p",null,"Alias: ",(0,l.kt)("inlineCode",{parentName:"p"},"ltrim(input_string)"),"."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"input_string")," \u2014 string to trim. ",(0,l.kt)("a",{parentName:"li",href:"/docs/staging4/docs/en/sql-reference/data-types/string"},"String"),".")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returned value")),(0,l.kt)("p",null,"A string without leading common whitespaces."),(0,l.kt)("p",null,"Type: ",(0,l.kt)("inlineCode",{parentName:"p"},"String"),"."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("p",null,"Query:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT trimLeft('     Hello, world!     ');\n")),(0,l.kt)("p",null,"Result:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-text"},"\u250c\u2500trimLeft('     Hello, world!     ')\u2500\u2510\n\u2502 Hello, world!                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")),(0,l.kt)("h2",{id:"trimright"},"trimRight"),(0,l.kt)("p",null,"Removes all consecutive occurrences of common whitespace (ASCII character 32) from the end of a string. It does not remove other kinds of whitespace characters (tab, no-break space, etc.)."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Syntax")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"trimRight(input_string)\n")),(0,l.kt)("p",null,"Alias: ",(0,l.kt)("inlineCode",{parentName:"p"},"rtrim(input_string)"),"."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"input_string")," \u2014 string to trim. ",(0,l.kt)("a",{parentName:"li",href:"/docs/staging4/docs/en/sql-reference/data-types/string"},"String"),".")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returned value")),(0,l.kt)("p",null,"A string without trailing common whitespaces."),(0,l.kt)("p",null,"Type: ",(0,l.kt)("inlineCode",{parentName:"p"},"String"),"."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("p",null,"Query:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT trimRight('     Hello, world!     ');\n")),(0,l.kt)("p",null,"Result:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-text"},"\u250c\u2500trimRight('     Hello, world!     ')\u2500\u2510\n\u2502      Hello, world!                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")),(0,l.kt)("h2",{id:"trimboth"},"trimBoth"),(0,l.kt)("p",null,"Removes all consecutive occurrences of common whitespace (ASCII character 32) from both ends of a string. It does not remove other kinds of whitespace characters (tab, no-break space, etc.)."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Syntax")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"trimBoth(input_string)\n")),(0,l.kt)("p",null,"Alias: ",(0,l.kt)("inlineCode",{parentName:"p"},"trim(input_string)"),"."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"input_string")," \u2014 string to trim. ",(0,l.kt)("a",{parentName:"li",href:"/docs/staging4/docs/en/sql-reference/data-types/string"},"String"),".")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returned value")),(0,l.kt)("p",null,"A string without leading and trailing common whitespaces."),(0,l.kt)("p",null,"Type: ",(0,l.kt)("inlineCode",{parentName:"p"},"String"),"."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("p",null,"Query:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT trimBoth('     Hello, world!     ');\n")),(0,l.kt)("p",null,"Result:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-text"},"\u250c\u2500trimBoth('     Hello, world!     ')\u2500\u2510\n\u2502 Hello, world!                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")),(0,l.kt)("h2",{id:"crc32"},"CRC32(s)"),(0,l.kt)("p",null,"Returns the CRC32 checksum of a string, using CRC-32-IEEE 802.3 polynomial and initial value ",(0,l.kt)("inlineCode",{parentName:"p"},"0xffffffff")," (zlib implementation)."),(0,l.kt)("p",null,"The result type is UInt32."),(0,l.kt)("h2",{id:"crc32ieee"},"CRC32IEEE(s)"),(0,l.kt)("p",null,"Returns the CRC32 checksum of a string, using CRC-32-IEEE 802.3 polynomial."),(0,l.kt)("p",null,"The result type is UInt32."),(0,l.kt)("h2",{id:"crc64"},"CRC64(s)"),(0,l.kt)("p",null,"Returns the CRC64 checksum of a string, using CRC-64-ECMA polynomial."),(0,l.kt)("p",null,"The result type is UInt64."),(0,l.kt)("h2",{id:"normalized-query"},"normalizeQuery"),(0,l.kt)("p",null,"Replaces literals, sequences of literals and complex aliases with placeholders."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Syntax")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"normalizeQuery(x)\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"x")," \u2014 Sequence of characters. ",(0,l.kt)("a",{parentName:"li",href:"/docs/staging4/docs/en/sql-reference/data-types/string"},"String"),".")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returned value")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Sequence of characters with placeholders.")),(0,l.kt)("p",null,"Type: ",(0,l.kt)("a",{parentName:"p",href:"/docs/staging4/docs/en/sql-reference/data-types/string"},"String"),"."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("p",null,"Query:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT normalizeQuery('[1, 2, 3, x]') AS query;\n")),(0,l.kt)("p",null,"Result:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-text"},"\u250c\u2500query\u2500\u2500\u2500\u2500\u2510\n\u2502 [?.., x] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")),(0,l.kt)("h2",{id:"normalized-query-hash"},"normalizedQueryHash"),(0,l.kt)("p",null,"Returns identical 64bit hash values without the values of literals for similar queries. It helps to analyze query log."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Syntax")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"normalizedQueryHash(x)\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"x")," \u2014 Sequence of characters. ",(0,l.kt)("a",{parentName:"li",href:"/docs/staging4/docs/en/sql-reference/data-types/string"},"String"),".")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returned value")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Hash value.")),(0,l.kt)("p",null,"Type: ",(0,l.kt)("a",{parentName:"p",href:"/docs/staging4/docs/en/sql-reference/data-types/int-uint#uint-ranges"},"UInt64"),"."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("p",null,"Query:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT normalizedQueryHash('SELECT 1 AS `xyz`') != normalizedQueryHash('SELECT 1 AS `abc`') AS res;\n")),(0,l.kt)("p",null,"Result:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-text"},"\u250c\u2500res\u2500\u2510\n\u2502   1 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n")),(0,l.kt)("h2",{id:"normalizeutf8nfc"},"normalizeUTF8NFC"),(0,l.kt)("p",null,"Converts a string to ",(0,l.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Unicode_equivalence#Normal_forms"},"NFC normalized form"),", assuming the string contains a set of bytes that make up a UTF-8 encoded text."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Syntax")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"normalizeUTF8NFC(words)\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"words")," \u2014 Input string that contains UTF-8 encoded text. ",(0,l.kt)("a",{parentName:"li",href:"/docs/staging4/docs/en/sql-reference/data-types/string"},"String"),".")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returned value")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"String transformed to NFC normalization form.")),(0,l.kt)("p",null,"Type: ",(0,l.kt)("a",{parentName:"p",href:"/docs/staging4/docs/en/sql-reference/data-types/string"},"String"),"."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("p",null,"Query:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT length('\xe2'), normalizeUTF8NFC('\xe2') AS nfc, length(nfc) AS nfc_len;\n")),(0,l.kt)("p",null,"Result:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-text"},"\u250c\u2500length('\xe2')\u2500\u252c\u2500nfc\u2500\u252c\u2500nfc_len\u2500\u2510\n\u2502           2 \u2502 \xe2   \u2502       2 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")),(0,l.kt)("h2",{id:"normalizeutf8nfd"},"normalizeUTF8NFD"),(0,l.kt)("p",null,"Converts a string to ",(0,l.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Unicode_equivalence#Normal_forms"},"NFD normalized form"),", assuming the string contains a set of bytes that make up a UTF-8 encoded text."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Syntax")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"normalizeUTF8NFD(words)\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"words")," \u2014 Input string that contains UTF-8 encoded text. ",(0,l.kt)("a",{parentName:"li",href:"/docs/staging4/docs/en/sql-reference/data-types/string"},"String"),".")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returned value")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"String transformed to NFD normalization form.")),(0,l.kt)("p",null,"Type: ",(0,l.kt)("a",{parentName:"p",href:"/docs/staging4/docs/en/sql-reference/data-types/string"},"String"),"."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("p",null,"Query:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT length('\xe2'), normalizeUTF8NFD('\xe2') AS nfd, length(nfd) AS nfd_len;\n")),(0,l.kt)("p",null,"Result:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-text"},"\u250c\u2500length('\xe2')\u2500\u252c\u2500nfd\u2500\u252c\u2500nfd_len\u2500\u2510\n\u2502           2 \u2502 a\u0302   \u2502       3 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")),(0,l.kt)("h2",{id:"normalizeutf8nfkc"},"normalizeUTF8NFKC"),(0,l.kt)("p",null,"Converts a string to ",(0,l.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Unicode_equivalence#Normal_forms"},"NFKC normalized form"),", assuming the string contains a set of bytes that make up a UTF-8 encoded text."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Syntax")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"normalizeUTF8NFKC(words)\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"words")," \u2014 Input string that contains UTF-8 encoded text. ",(0,l.kt)("a",{parentName:"li",href:"/docs/staging4/docs/en/sql-reference/data-types/string"},"String"),".")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returned value")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"String transformed to NFKC normalization form.")),(0,l.kt)("p",null,"Type: ",(0,l.kt)("a",{parentName:"p",href:"/docs/staging4/docs/en/sql-reference/data-types/string"},"String"),"."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("p",null,"Query:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT length('\xe2'), normalizeUTF8NFKC('\xe2') AS nfkc, length(nfkc) AS nfkc_len;\n")),(0,l.kt)("p",null,"Result:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-text"},"\u250c\u2500length('\xe2')\u2500\u252c\u2500nfkc\u2500\u252c\u2500nfkc_len\u2500\u2510\n\u2502           2 \u2502 \xe2    \u2502        2 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")),(0,l.kt)("h2",{id:"normalizeutf8nfkd"},"normalizeUTF8NFKD"),(0,l.kt)("p",null,"Converts a string to ",(0,l.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Unicode_equivalence#Normal_forms"},"NFKD normalized form"),", assuming the string contains a set of bytes that make up a UTF-8 encoded text."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Syntax")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"normalizeUTF8NFKD(words)\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"words")," \u2014 Input string that contains UTF-8 encoded text. ",(0,l.kt)("a",{parentName:"li",href:"/docs/staging4/docs/en/sql-reference/data-types/string"},"String"),".")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returned value")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"String transformed to NFKD normalization form.")),(0,l.kt)("p",null,"Type: ",(0,l.kt)("a",{parentName:"p",href:"/docs/staging4/docs/en/sql-reference/data-types/string"},"String"),"."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("p",null,"Query:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT length('\xe2'), normalizeUTF8NFKD('\xe2') AS nfkd, length(nfkd) AS nfkd_len;\n")),(0,l.kt)("p",null,"Result:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-text"},"\u250c\u2500length('\xe2')\u2500\u252c\u2500nfkd\u2500\u252c\u2500nfkd_len\u2500\u2510\n\u2502           2 \u2502 a\u0302    \u2502        3 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")),(0,l.kt)("h2",{id:"encode-xml-component"},"encodeXMLComponent"),(0,l.kt)("p",null,"Escapes characters to place string into XML text node or attribute."),(0,l.kt)("p",null,"The following five XML predefined entities will be replaced: ",(0,l.kt)("inlineCode",{parentName:"p"},"<"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"&"),", ",(0,l.kt)("inlineCode",{parentName:"p"},">"),", ",(0,l.kt)("inlineCode",{parentName:"p"},'"'),", ",(0,l.kt)("inlineCode",{parentName:"p"},"'"),"."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Syntax")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"encodeXMLComponent(x)\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"x")," \u2014 The sequence of characters. ",(0,l.kt)("a",{parentName:"li",href:"/docs/staging4/docs/en/sql-reference/data-types/string"},"String"),".")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returned value")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The sequence of characters with escape characters.")),(0,l.kt)("p",null,"Type: ",(0,l.kt)("a",{parentName:"p",href:"/docs/staging4/docs/en/sql-reference/data-types/string"},"String"),"."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("p",null,"Query:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT encodeXMLComponent('Hello, \"world\"!');\nSELECT encodeXMLComponent('<123>');\nSELECT encodeXMLComponent('&clickhouse');\nSELECT encodeXMLComponent('\\'foo\\'');\n")),(0,l.kt)("p",null,"Result:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-text"},"Hello, &quot;world&quot;!\n&lt;123&gt;\n&amp;clickhouse\n&apos;foo&apos;\n")),(0,l.kt)("h2",{id:"decode-xml-component"},"decodeXMLComponent"),(0,l.kt)("p",null,"Replaces XML predefined entities with characters. Predefined entities are ",(0,l.kt)("inlineCode",{parentName:"p"},"&quot;")," ",(0,l.kt)("inlineCode",{parentName:"p"},"&amp;")," ",(0,l.kt)("inlineCode",{parentName:"p"},"&apos;")," ",(0,l.kt)("inlineCode",{parentName:"p"},"&gt;")," ",(0,l.kt)("inlineCode",{parentName:"p"},"&lt;"),"\nThis function also replaces numeric character references with Unicode characters. Both decimal (like ",(0,l.kt)("inlineCode",{parentName:"p"},"&#10003;"),") and hexadecimal (",(0,l.kt)("inlineCode",{parentName:"p"},"&#x2713;"),") forms are supported."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Syntax")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"decodeXMLComponent(x)\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"x")," \u2014 A sequence of characters. ",(0,l.kt)("a",{parentName:"li",href:"/docs/staging4/docs/en/sql-reference/data-types/string"},"String"),".")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returned value")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The sequence of characters after replacement.")),(0,l.kt)("p",null,"Type: ",(0,l.kt)("a",{parentName:"p",href:"/docs/staging4/docs/en/sql-reference/data-types/string"},"String"),"."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("p",null,"Query:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT decodeXMLComponent('&apos;foo&apos;');\nSELECT decodeXMLComponent('&lt; &#x3A3; &gt;');\n")),(0,l.kt)("p",null,"Result:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-text"},"'foo'\n< \u03a3 >\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"See Also")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references"},"List of XML and HTML character entity references"))),(0,l.kt)("h2",{id:"extracttextfromhtml"},"extractTextFromHTML"),(0,l.kt)("p",null,"A function to extract text from HTML or XHTML.\nIt does not necessarily 100% conform to any of the HTML, XML or XHTML standards, but the implementation is reasonably accurate and it is fast. The rules are the following:"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"Comments are skipped. Example: ",(0,l.kt)("inlineCode",{parentName:"li"},"\x3c!-- test --\x3e"),". Comment must end with ",(0,l.kt)("inlineCode",{parentName:"li"},"--\x3e"),". Nested comments are not possible.\nNote: constructions like ",(0,l.kt)("inlineCode",{parentName:"li"},"\x3c!--\x3e")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"\x3c!---\x3e")," are not valid comments in HTML but they are skipped by other rules."),(0,l.kt)("li",{parentName:"ol"},'CDATA is pasted verbatim. Note: CDATA is XML/XHTML specific. But it is processed for "best-effort" approach.'),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("inlineCode",{parentName:"li"},"script")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"style")," elements are removed with all their content. Note: it is assumed that closing tag cannot appear inside content. For example, in JS string literal has to be escaped like ",(0,l.kt)("inlineCode",{parentName:"li"},'"<\\/script>"'),".\nNote: comments and CDATA are possible inside ",(0,l.kt)("inlineCode",{parentName:"li"},"script")," or ",(0,l.kt)("inlineCode",{parentName:"li"},"style")," - then closing tags are not searched inside CDATA. Example: ",(0,l.kt)("inlineCode",{parentName:"li"},"<script><![CDATA[<\/script>]]><\/script>"),". But they are still searched inside comments. Sometimes it becomes complicated: ",(0,l.kt)("inlineCode",{parentName:"li"},'<script>var x = "\x3c!--"; <\/script> var y = "--\x3e"; alert(x + y);<\/script>'),"\nNote: ",(0,l.kt)("inlineCode",{parentName:"li"},"script")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"style")," can be the names of XML namespaces - then they are not treated like usual ",(0,l.kt)("inlineCode",{parentName:"li"},"script")," or ",(0,l.kt)("inlineCode",{parentName:"li"},"style")," elements. Example: ",(0,l.kt)("inlineCode",{parentName:"li"},"<script:a>Hello</script:a>"),".\nNote: whitespaces are possible after closing tag name: ",(0,l.kt)("inlineCode",{parentName:"li"},"<\/script >")," but not before: ",(0,l.kt)("inlineCode",{parentName:"li"},"< / script>"),"."),(0,l.kt)("li",{parentName:"ol"},"Other tags or tag-like elements are skipped without inner content. Example: ",(0,l.kt)("inlineCode",{parentName:"li"},"<a>.</a>"),"\nNote: it is expected that this HTML is illegal: ",(0,l.kt)("inlineCode",{parentName:"li"},'<a test=">"></a>'),"\nNote: it also skips something like tags: ",(0,l.kt)("inlineCode",{parentName:"li"},"<>"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"<!>"),", etc.\nNote: tag without end is skipped to the end of input: ",(0,l.kt)("inlineCode",{parentName:"li"},"<hello   ")),(0,l.kt)("li",{parentName:"ol"},"HTML and XML entities are not decoded. They must be processed by separate function."),(0,l.kt)("li",{parentName:"ol"},"Whitespaces in the text are collapsed or inserted by specific rules.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Whitespaces at the beginning and at the end are removed."),(0,l.kt)("li",{parentName:"ul"},"Consecutive whitespaces are collapsed."),(0,l.kt)("li",{parentName:"ul"},"But if the text is separated by other elements and there is no whitespace, it is inserted."),(0,l.kt)("li",{parentName:"ul"},"It may cause unnatural examples: ",(0,l.kt)("inlineCode",{parentName:"li"},"Hello<b>world</b>"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"Hello\x3c!-- --\x3eworld")," - there is no whitespace in HTML, but the function inserts it. Also consider: ",(0,l.kt)("inlineCode",{parentName:"li"},"Hello<p>world</p>"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"Hello<br>world"),". This behavior is reasonable for data analysis, e.g. to convert HTML to a bag of words."))),(0,l.kt)("li",{parentName:"ol"},"Also note that correct handling of whitespaces requires the support of ",(0,l.kt)("inlineCode",{parentName:"li"},"<pre></pre>")," and CSS ",(0,l.kt)("inlineCode",{parentName:"li"},"display")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"white-space")," properties.")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Syntax")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"extractTextFromHTML(x)\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Arguments")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"x")," \u2014 input text. ",(0,l.kt)("a",{parentName:"li",href:"/docs/staging4/docs/en/sql-reference/data-types/string"},"String"),".")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Returned value")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Extracted text.")),(0,l.kt)("p",null,"Type: ",(0,l.kt)("a",{parentName:"p",href:"/docs/staging4/docs/en/sql-reference/data-types/string"},"String"),"."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example")),(0,l.kt)("p",null,"The first example contains several tags and a comment and also shows whitespace processing.\nThe second example shows ",(0,l.kt)("inlineCode",{parentName:"p"},"CDATA")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"script")," tag processing.\nIn the third example text is extracted from the full HTML response received by the ",(0,l.kt)("a",{parentName:"p",href:"/docs/staging4/docs/en/sql-reference/table-functions/url"},"url")," function."),(0,l.kt)("p",null,"Query:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT extractTextFromHTML(' <p> A text <i>with</i><b>tags</b>. \x3c!-- comments --\x3e </p> ');\nSELECT extractTextFromHTML('<![CDATA[The content within <b>CDATA</b>]]> <script>alert(\"Script\");<\/script>');\nSELECT extractTextFromHTML(html) FROM url('http://www.donothingfor2minutes.com/', RawBLOB, 'html String');\n")),(0,l.kt)("p",null,"Result:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-text"},"A text with tags .\nThe content within <b>CDATA</b>\nDo Nothing for 2 Minutes 2:00 &nbsp;\n")))}m.isMDXComponent=!0}}]);