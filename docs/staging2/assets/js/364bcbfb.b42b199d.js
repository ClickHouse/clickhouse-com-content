"use strict";(self.webpackChunkclickhouse=self.webpackChunkclickhouse||[]).push([[80443],{3905:function(e,t,a){a.d(t,{Zo:function(){return m},kt:function(){return d}});var n=a(67294);function l(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){l(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,l=function(e,t){if(null==e)return{};var a,n,l={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(l[a]=e[a]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var c=n.createContext({}),s=function(e){var t=n.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},m=function(e){var t=s(e.components);return n.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,l=e.mdxType,r=e.originalType,c=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),u=s(a),d=l,f=u["".concat(c,".").concat(d)]||u[d]||p[d]||r;return a?n.createElement(f,i(i({ref:t},m),{},{components:a})):n.createElement(f,i({ref:t},m))}));function d(e,t){var a=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var r=a.length,i=new Array(r);i[0]=u;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:l,i[1]=o;for(var s=2;s<r;s++)i[s]=a[s];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},55216:function(e,t,a){a.r(t),a.d(t,{assets:function(){return m},contentTitle:function(){return c},default:function(){return d},frontMatter:function(){return o},metadata:function(){return s},toc:function(){return p}});var n=a(87462),l=a(63366),r=(a(67294),a(3905)),i=["components"],o={sidebar_position:42,sidebar_label:"Decimal"},c="Decimal(P, S), Decimal32(S), Decimal64(S), Decimal128(S), Decimal256(S)",s={unversionedId:"en/sql-reference/data-types/decimal",id:"en/sql-reference/data-types/decimal",title:"Decimal(P, S), Decimal32(S), Decimal64(S), Decimal128(S), Decimal256(S)",description:"decimal}",source:"@site/docs/en/sql-reference/data-types/decimal.md",sourceDirName:"en/sql-reference/data-types",slug:"/en/sql-reference/data-types/decimal",permalink:"/docs/staging2/docs/en/sql-reference/data-types/decimal",tags:[],version:"current",sidebarPosition:42,frontMatter:{sidebar_position:42,sidebar_label:"Decimal"},sidebar:"tutorialSidebar",previous:{title:"Float32, Float64",permalink:"/docs/staging2/docs/en/sql-reference/data-types/float"},next:{title:"Boolean",permalink:"/docs/staging2/docs/en/sql-reference/data-types/boolean"}},m={},p=[{value:"Parameters",id:"parameters",level:2},{value:"Decimal Value Ranges",id:"decimal-value-ranges",level:2},{value:"Internal Representation",id:"internal-representation",level:2},{value:"Operations and Result Type",id:"operations-and-result-type",level:2},{value:"Overflow Checks",id:"overflow-checks",level:2}],u={toc:p};function d(e){var t=e.components,a=(0,l.Z)(e,i);return(0,r.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"decimal"},"Decimal(P, S), Decimal32(S), Decimal64(S), Decimal128(S), Decimal256(S)"),(0,r.kt)("p",null,"Signed fixed-point numbers that keep precision during add, subtract and multiply operations. For division least significant digits are discarded (not rounded)."),(0,r.kt)("h2",{id:"parameters"},"Parameters"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"P - precision. Valid range: ","["," 1 : 76 ","]",". Determines how many decimal digits number can have (including fraction)."),(0,r.kt)("li",{parentName:"ul"},"S - scale. Valid range: ","["," 0 : P ","]",". Determines how many decimal digits fraction can have.")),(0,r.kt)("p",null,"Depending on P parameter value Decimal(P, S) is a synonym for:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"P from ","["," 1 : 9 ","]"," - for Decimal32(S)"),(0,r.kt)("li",{parentName:"ul"},"P from ","["," 10 : 18 ","]"," - for Decimal64(S)"),(0,r.kt)("li",{parentName:"ul"},"P from ","["," 19 : 38 ","]"," - for Decimal128(S)"),(0,r.kt)("li",{parentName:"ul"},"P from ","["," 39 : 76 ","]"," - for Decimal256(S)")),(0,r.kt)("h2",{id:"decimal-value-ranges"},"Decimal Value Ranges"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Decimal32(S) - ( -1 ","*"," 10^(9 - S), 1 ","*"," 10^(9 - S) )"),(0,r.kt)("li",{parentName:"ul"},"Decimal64(S) - ( -1 ","*"," 10^(18 - S), 1 ","*"," 10^(18 - S) )"),(0,r.kt)("li",{parentName:"ul"},"Decimal128(S) - ( -1 ","*"," 10^(38 - S), 1 ","*"," 10^(38 - S) )"),(0,r.kt)("li",{parentName:"ul"},"Decimal256(S) - ( -1 ","*"," 10^(76 - S), 1 ","*"," 10^(76 - S) )")),(0,r.kt)("p",null,"For example, Decimal32(4) can contain numbers from -99999.9999 to 99999.9999 with 0.0001 step."),(0,r.kt)("h2",{id:"internal-representation"},"Internal Representation"),(0,r.kt)("p",null,"Internally data is represented as normal signed integers with respective bit width. Real value ranges that can be stored in memory are a bit larger than specified above, which are checked only on conversion from a string."),(0,r.kt)("p",null,"Because modern CPUs do not support 128-bit integers natively, operations on Decimal128 are emulated. Because of this Decimal128 works significantly slower than Decimal32/Decimal64."),(0,r.kt)("h2",{id:"operations-and-result-type"},"Operations and Result Type"),(0,r.kt)("p",null,"Binary operations on Decimal result in wider result type (with any order of arguments)."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Decimal64(S1) <op> Decimal32(S2) -> Decimal64(S)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Decimal128(S1) <op> Decimal32(S2) -> Decimal128(S)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Decimal128(S1) <op> Decimal64(S2) -> Decimal128(S)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Decimal256(S1) <op> Decimal<32|64|128>(S2) -> Decimal256(S)"))),(0,r.kt)("p",null,"Rules for scale:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"add, subtract: S = max(S1, S2)."),(0,r.kt)("li",{parentName:"ul"},"multuply: S = S1 + S2."),(0,r.kt)("li",{parentName:"ul"},"divide: S = S1.")),(0,r.kt)("p",null,"For similar operations between Decimal and integers, the result is Decimal of the same size as an argument."),(0,r.kt)("p",null,"Operations between Decimal and Float32/Float64 are not defined. If you need them, you can explicitly cast one of argument using toDecimal32, toDecimal64, toDecimal128 or toFloat32, toFloat64 builtins. Keep in mind that the result will lose precision and type conversion is a computationally expensive operation."),(0,r.kt)("p",null,"Some functions on Decimal return result as Float64 (for example, var or stddev). Intermediate calculations might still be performed in Decimal, which might lead to different results between Float64 and Decimal inputs with the same values."),(0,r.kt)("h2",{id:"overflow-checks"},"Overflow Checks"),(0,r.kt)("p",null,"During calculations on Decimal, integer overflows might happen. Excessive digits in a fraction are discarded (not rounded). Excessive digits in integer part will lead to an exception."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT toDecimal32(2, 4) AS x, x / 3\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"\u250c\u2500\u2500\u2500\u2500\u2500\u2500x\u2500\u252c\u2500divide(toDecimal32(2, 4), 3)\u2500\u2510\n\u2502 2.0000 \u2502                       0.6666 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT toDecimal32(4.2, 8) AS x, x * x\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"DB::Exception: Scale is out of bounds.\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT toDecimal32(4.2, 8) AS x, 6 * x\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"DB::Exception: Decimal math overflow.\n")),(0,r.kt)("p",null,"Overflow checks lead to operations slowdown. If it is known that overflows are not possible, it makes sense to disable checks using ",(0,r.kt)("inlineCode",{parentName:"p"},"decimal_check_overflow")," setting. When checks are disabled and overflow happens, the result will be incorrect:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SET decimal_check_overflow = 0;\nSELECT toDecimal32(4.2, 8) AS x, 6 * x\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500x\u2500\u252c\u2500multiply(6, toDecimal32(4.2, 8))\u2500\u2510\n\u2502 4.20000000 \u2502                     -17.74967296 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n")),(0,r.kt)("p",null,"Overflow checks happen not only on arithmetic operations but also on value comparison:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT toDecimal32(1, 8) < 100\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"DB::Exception: Can't compare.\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"See also")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/staging2/docs/en/sql-reference/functions/other-functions#is-decimal-overflow"},"isDecimalOverflow")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/staging2/docs/en/sql-reference/functions/other-functions#count-digits"},"countDigits"))),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://clickhouse.com/docs/en/data_types/decimal/"},"Original article")," "))}d.isMDXComponent=!0}}]);